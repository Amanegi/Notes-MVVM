package com.amannegi.notes.screens

import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.lifecycle.ViewModelProvider
import androidx.navigation.fragment.navArgs
import com.amannegi.notes.database.Note
import com.amannegi.notes.database.NoteViewModel
import com.amannegi.notes.databinding.NoteBottomSheetBinding
import com.amannegi.notes.utils.SessionManager
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import java.text.SimpleDateFormat
import java.util.*


class NoteBottomSheetFragment : BottomSheetDialogFragment() {
    private lateinit var binding: NoteBottomSheetBinding
    private val args: NoteBottomSheetFragmentArgs by navArgs()


    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        binding = NoteBottomSheetBinding.inflate(inflater, container, false)

        // fetching the note passed in safe args
        val currentNote = args.currentNote

        // making UI changes if note is received in safe args
        if (currentNote != null) {
            binding.inputTitle.setText(currentNote.title)
            binding.inputBody.setText(currentNote.body)
            binding.btnSave.text = "Update"
        }

        // requesting cursor on title edittext on launch
        binding.inputTitle.requestFocus()

        binding.btnCancel.setOnClickListener {
            dismiss()
        }

        // adding textwatcher to handle error on title edittext
        binding.inputTitle.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {
            }

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                binding.titleTextField.error = null
            }

            override fun afterTextChanged(s: Editable?) {
                // set error if edittext is empty
                if (s.toString().isEmpty()) {
                    binding.titleTextField.error = "Title can't be empty"
                }
            }

        })

        binding.btnSave.setOnClickListener {
            val viewModel = ViewModelProvider(this).get(NoteViewModel::class.java)
            val title = binding.inputTitle.text.toString().trim()
            val body = binding.inputBody.text.toString().trim()
            val email = SessionManager(requireContext()).getEmail()
            val simpleDateFormat = SimpleDateFormat("dd/MMM/yyyy hh:mm:ss")
            val timestamp = simpleDateFormat.format(Date())

            if (currentNote == null) {
                // for create note
                val createdTimestamp = "Created on: ${timestamp}"
                // uid will be discarded by room and will be autogenerated
                val note = Note(0, title, body, email!!, createdTimestamp)

                if (binding.titleTextField.error == null) {
                    viewModel.saveNote(note)
                    dismiss()
                }
            } else {
                // for update note
                val updatedTimestamp = "Updated on: ${timestamp}"
                // original uid passed for updation in  db
                val note = Note(currentNote.uid, title, body, email!!, updatedTimestamp)

                if (binding.titleTextField.error == null) {
                    viewModel.updateNote(note)
                    dismiss()
                }
            }


        }

        return binding.root
    }
}